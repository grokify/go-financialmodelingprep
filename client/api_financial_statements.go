/*
Financial Modeling Prep API

FMP provides one of the most accurate data available on the market. Every endpoint is available in JSON format and most of them also in CSV format. Data is coming right from SEC filings after being serialized by us. Our API has over 50 endpoints and we are still growing by adding new endpoints every week. We also provide on demand custom endpoint available for our business clients.

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// FinancialStatementsApiService FinancialStatementsApi service
type FinancialStatementsApiService service

type ApiGetIncomeStatementsRequest struct {
	ctx        context.Context
	ApiService *FinancialStatementsApiService
	symbol     string
	limit      *int32
	period     *string
	apikey     *string
	datatype   *string
}

// Number of results to return.
func (r ApiGetIncomeStatementsRequest) Limit(limit int32) ApiGetIncomeStatementsRequest {
	r.limit = &limit
	return r
}

// Specify a quarterly income statement. Default is annual.
func (r ApiGetIncomeStatementsRequest) Period(period string) ApiGetIncomeStatementsRequest {
	r.period = &period
	return r
}

// API key for authn / authz
func (r ApiGetIncomeStatementsRequest) Apikey(apikey string) ApiGetIncomeStatementsRequest {
	r.apikey = &apikey
	return r
}

// Format of data to return
func (r ApiGetIncomeStatementsRequest) Datatype(datatype string) ApiGetIncomeStatementsRequest {
	r.datatype = &datatype
	return r
}

func (r ApiGetIncomeStatementsRequest) Execute() (*IncomeStatementListResponse, *http.Response, error) {
	return r.ApiService.GetIncomeStatementsExecute(r)
}

/*
GetIncomeStatements Get Income Statements

Retreive income statements for stocks by symbol or CIK.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiGetIncomeStatementsRequest
*/
func (a *FinancialStatementsApiService) GetIncomeStatements(ctx context.Context, symbol string) ApiGetIncomeStatementsRequest {
	return ApiGetIncomeStatementsRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return IncomeStatementListResponse
func (a *FinancialStatementsApiService) GetIncomeStatementsExecute(r ApiGetIncomeStatementsRequest) (*IncomeStatementListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IncomeStatementListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FinancialStatementsApiService.GetIncomeStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/income-statement/{symbol}"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterToString(r.symbol, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	if r.datatype != nil {
		localVarQueryParams.Add("datatype", parameterToString(*r.datatype, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
